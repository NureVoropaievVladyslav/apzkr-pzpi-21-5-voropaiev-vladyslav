Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для спостереження за станом ставів для розведення риби

     Студент гр. ПЗПІ-21-5                                Воропаєв В.О.
(підпис)
Керівник роботи                     __________________ ст. викл. Сокорчук І.П.
             (підпис)

Роботу захищено «__»_________ 2022 р.
з оцінкою _________________________

       Комісія:                                    _________________ доц. Лещинський В.О.
        (підпис)
                                                         _________________ доц. Лещинська І.О.
 (підпис)
                                                             _________________ ст. викл. Сокорчук І.П.
(підпис)


Харків 
2024 р.
Харківський національний університет радіоелектроніки
     
Факультет       комп’ютерних наук     Кафедра    програмної інженерії______    Спеціальність    121 – Інженерія програмного забезпечення_______________                         
Курс               3            Семестр                       6                                                       т Навчальна дисципліна Архітектура програмного забезпеченя                          а
     
     ЗАВДАННЯ
     НА КУРСОВУ РОБОТУ СТУДЕНТОВІ
     
                                      Воропаєву Владиславу Олексійовичу                                        о           
1. Тема роботи: «Програмна система для спостереження за станом ставів для розведення риби»                                                                                                                    .                                                                                                                       
2. Термін узгодження завдання з курсової роботи « 25 » березня 2022 р. 
3. Термін здачі студентом закінченої роботи « 1 »  червня  2022 р.  
4. Вихідні дані до проєкту: Vision and Scope.                                                                                                                                                              
5. Зміст пояснювальної записки (перелік питань, що належить  розробити)
Лабораторна робота №1 – розробити аркуш завдання та описати проект у форматі Vision & Scope. Лабораторна робота №2 – розробити серверну частину програмної системи. Лабораторна робота №3 – розробити програмну частину для IoT пристрою. Лабораторна робота №4 – розробити клієнтську частину програмної системи. Лабораторна робота №5 – розробити мобільну частину програмної системи            
6. Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень)
UML діаграма розгортання (Deployment Diagram), UML діаграма прецедентів  (Use Case Diagram),, ER-модель даних (Entity–Relationship Model), UML       діаграма взаємодії (Interaction Overview Diagram), UML діаграму діяльності (Activity Diagram), UML діаграма компонент (Component Diagram).                0 


     КАЛЕНДАРНИЙ ПЛАН 
     
     
     
№Основні етапи виконання проєкту
в рамках лабораторних робітТермін виконанняПримітка1Описати проєкт у форматі Vision & Scope06.04.2024виконано2Розробити серверну частину програмної системи20.04.2024виконано3Розробити програмне забезпечення для пристрою інтернету речей04.05.20244Розробити клієнтську частину
програмної системи18.05.2024виконано5Розробити мобільний програмний застосунок для платформи Android 01.06.2024виконано     

Дата видачі теми проєкту «25» березня 2024 р.
  

Викладач лабораторних робіт _______ ст. вик. каф. ПІ Сокорчук І.П.
	      				(підпис)


Завдання прийняв до виконання ст.гр. ПЗПІ-21-5 Воропаєв В. О.
	      							   (підпис)
      
     
РЕФЕРАТ
     
     
     Пояснювальна записка до курсової роботи: 66 с., 21 рис., 1 табл., 10 додатків, 8 джерел. 
     АВТОНОМНА РОБОТА, ЗДОРОВ’Я ПОПУЛЯЦІЇ, КРИТИЧНЕ СПОВІЩЕННЯ, ПОКАЗНИКИ КОРИСНИХ РЕЧОВИН, РИБА, РИБОРОЗПЛІДНЕННЯ, СТАВ, ХВОРОБИ.
     
     
     Об’єктом дослідження є індустрія розведення риби та актуальне питання спостереження за станом ставів та популяції риби в реальному часі без необхідності в постійній присутності працівників.
     Метою курсової роботи є створення програмної системи, яка надає функціональність адміністрування даних та створення інформації про стави, що містить дані про популяцію риби, а також ключові показники розчинності корисних речовин.
     Методологія розробки базується на використанні предметно-орієнтовного програмування. Для реалізації серверної частини системи використовується платформа .NET та система керування базами даних PostgreSQL. Веб частина система базується на технології Angular, HTML, SASS та TypeScript. Мобільний застосунок створюється за допомогою платформи MAUI та мови С#.
     Результатом роботи є реалізація програмної системи для спостереження за станом ставів для розведення риби. Розроблена система складається з трьох частин: серверна, веб та мобільна.
     
ЗМІСТ
     
     
ВСТУП	7
1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ	8
1.1 Аналіз ринку та можливості для бізнесу	8
1.2 Вимоги до частин системи	10
2 РОЗРОБКА СЕВЕРНОЇ ЧАСТИНИ ПРОЕКТУ	12
2.1 Опис прийнятих інженерних рішень та архітектура системи	12
2.2 Побудова діаграми розгортання	13
2.3 Побудова ER-діаграми	14
2.4 Опис архітектури серверної частини	15
2.4.1 Створення бази даних та робота з даними	15
2.4.2 Використання CQRS, MediatR та контролерів	17
2.4.3 Обробка помилок	19
2.4.4 Бізнес логіка	20
2.4.5 Можливість адміністрування системи	21
2.4.6 Локалізація	22
2.4.7 Інтернаціоналізація	23
2.4.8 Облік часу	23
2.4.9 Захист даних	24
2.5 Побудова діаграми прецедентів	24
2.6 Специфікація REST	26
2.7 Побудова діаграми компонентів	28
3 РОЗРОБКА ВЕБ ЧАСТИНИ ПРОЕКТУ	29
3.1 Опис прийнятих інженерних рішень та веб-компонентів	29
3.2 Реалізація веб-частини системи	32
3.2.1 Авторизація та управління доступом користувачів	32
3.2.2 Обробка помилок	33
3.2.3 Можливість адміністрування системи	33
3.2.4 Локалізація	34
3.2.5 Облік часу	36
3.2.6 Бізнес логіка	36
4 РОЗРОБКА МОБІЛЬНОЇ ЧАСТИНИ ПРОЕКТУ	37
4.1 Опис прийнятих інженерних рішень та компонентів	37
4.2 Реалізація мобільної частини системи	38
4.2.1 Авторизація та управління доступом користувачів	38
4.2.2 Можливість адміністрування системи	39
4.2.3 Бізнес логіка	40
4.2.4 Локалізація	42
ВИСНОВКИ	44
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ	45
ДОДАТОК А	46
ДОДАТОК Б	49
ДОДАТОК В	52
ДОДАТОК Г	54
ДОДАТОК Д	56
ДОДАТОК Е	58
ДОДАТОК Ж	60
ДОДАТОК К	63
ДОДАТОК Л	65
ДОДАТОК М	66
     
     
     
     
     
     
     
     
     
ВСТУП
     
     
     Розроблена програмна система може бути використана для комплексного дослідження стану рибних популяцій у риборозплідних ставах. Метою розробки системи є полегшення та автоматизація процесів догляду за водними ділянками.
     Будь який власник бізнесу прагне максимально знизити кількість людських ресурсів задля того, щоб полегшити легкість керування своїми справами та знизити потенційні ризики. Автоматичні та вчасні повідомлення про стан ставу підвищують шанс на прогресивну динаміку рибних популяцій та прибирають необхідність у постійному за ними догляді.
     Власники бізнесу мають необхідність у постійному догляді та аналізі показників ставів та рибних популяцій, а також вчасні повідомлення про будь які зміни.
     Працівники ділянок мають доступ до ключових елементів системи, які їм доступні. Таким чином, система не передбачає несанкціонованого доступу до критично важливих даних. В той же час, довірені особи мають можливість адміністрування наявної інформації. Створення такої системи здатне здійснити революцію в управлінні риборозплідними ставами та полегшити всі пов’язані з цим процеси.
     


1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1 Аналіз ринку та можливості для бізнесу


     Великий попит на практики сталої аквакультури створює переконливі бізнес-можливості для розробки програмного забезпечення для спостереження за риборозплідними ставами. Оскільки галузь аквакультури прагне задовольнити світовий попит на рибні продукти, виникає гостра потреба в інноваційних рішеннях, які оптимізують процеси управління ставками, забезпечуючи при цьому екологічну стійкість.
     У цьому конкурентному середовищі розроблювана система постає як інноваційне рішення, що здатне здійснити революцію в управлінні риборозплідними ставами. Хоча деякі продукти пропонують похвальні функції для спостереження за станом ставів, їм часто не вистачає комплексного віддаленого доступу та масштабованості. Програмний продукт усуває ці обмеження, пропонуючи безперешкодний віддалений доступ через інтуїтивно зрозумілі додатки, що дає можливість водним фахівцям віддалено контролювати стан ставу незалежно від географічного розташування. Модель монетизації включає в себе два види підписок: стандартна абонентська плата та преміум підписка. Перший вид включає в себе стандартну плату за використання системи, яка залежить від обсягу користувачів та кількості ставів. Другий вид передбачає надання додаткового функціоналу, такого як, розширені аналітичні інструменти чи інтеграція з іншими системами. Окрім цього, як додаткове джерело монетизації може бути розглянута можливість партнерства з іншими компаніями, рекламні угоди тощо.
     З конкурентів можна відзначити Aquabyte [2] та CageEye [4]. У порівнянні з першим конкурентом, система надає більш широкий спектр функціональності, який включає управління водними процесами в цілому. Розроблювана система може інтегрувати дані про якість води, параметри середовища та інші важливі аспекти водного виробництва. Такий комплексний підхід дозволяє фахівцям отримувати більш повну картину стану їхніх ставів та ефективно реагувати на можливі проблеми.
     Крім того, система забезпечує більшу гнучкість у виборі способу спостереження та управління, що враховує індивідуальні потреби кожного водного фахівця. Наприклад, вона може підтримувати різні типи датчиків та пристроїв для збору даних, а також надавати можливість налаштування різних алгоритмів аналізу в залежності від потреб користувача.
     Це робить систему більш адаптованою до різних умов та потреб фахівців, що сприяє підвищенню ефективності вирощування риби та забезпеченню стійкості бізнесу.
     Іншим конкурентом є CageEye, що надає онлайн-платформу для спостереження за параметрами води та вирощування риби. Проте, високі витрати на впровадження та підтримку відштовхують потенційних клієнтів. Розроблювана система може бути більш доступною за ціною та пропонувати гнучкі тарифні плани, що забезпечить ефективніше використання фахівцями.
     Також, програмний продукт пропонує розширені можливості аналітики та звітності, що дозволяє водним фермерам отримувати більш детальну та точну інформацію про стан їхніх водних об'єктів.
     Розроблювана система включає в себе передові технології для проактивного управління хворобами, тим самим зменшуючи потенційні ризики для здоров'я рибних популяцій. Використовуючи передові алгоритми виявлення хвороб та інструменти аналітики, застосунок надає можливість фахівцям впроваджувати стратегії проактивного управління хворобами, мінімізуючи втрати та максимізуючи продуктивність.
     
     
     
     
     
     
1.2 Вимоги до частин системи
     
     
     Система буде включати в себе функціональність для чотирьох складових системи, які будуть доступні для низки користувачів з різними ролями доступу (неавторизований користувач, працівник та адміністратор).
     Серверна частина:
̶ реєстрація, автентифікація та управління даними користувачів;
̶ забезпечення захисту персональних даних;
̶ сповіщення про критичні зміни параметрів якості води;
̶ створення та управління графіками годування на основі даних про стан ставу та навколишнього середовища;
̶ система сповіщення про важливі події, такі як спалахи захворювань або несправності обладнання;
̶ генерація звітів та аналітики про стан здоров'я, продуктивність та екологічні тенденції ставу;
̶ призначення ролей і управління правами доступу для користувачів і адміністраторів;
̶ функціональність для адміністрування користувачів та ставів та створення резервних копій цих даних.
     Клієнтська частина (адміністрування):
̶ авторизація та автентифікація;
̶ керування користувачами, включно зі створенням, редагуванням і видаленням, з рольовим контролем доступу;
̶ моніторинг та звітність в режимі реального часу про стан ставу та параметри навколишнього середовища;
̶ створення, редагування та видалення графіків годування з гнучкими можливостями планування;
̶ сповіщення про критичні події, що потребують негайної уваги, такі як відхилення якості води;
̶ візуалізація даних про став в режимі реального часу за допомогою налаштовуваних інформаційних панелей з інтерактивними графіками та діаграмами.
     Мобільний додаток:
̶ авторизація та автентифікація;
̶ перегляд та редагування інформації особистого профілю;
̶ спостереження в режимі реального часу за станом ставу та параметрів якості води;
̶ автоматичні сповіщення про зміни критичних параметрів ставу для своєчасного втручання;
̶ доступ до історичних даних і аналіз тенденцій для прийняття обґрунтованих рішень і планування;
̶ інтеграція з пристроями інтернету речей для дистанційного керування та моніторингу обладнання ставу;
̶ підтримка доступу без інтернету до основних функцій і даних для роботи у віддалених місцях.
2 РОЗРОБКА СЕВЕРНОЇ ЧАСТИНИ ПРОЕКТУ
2.1 Опис прийнятих інженерних рішень та архітектура системи
     
     
     Розроблювана програмна система має в своєму основі архітектуру, що складається з п'яти шарів. Ця структура ґрунтується на концепціях предметно-орієнтованого проектування, що передбачає використання об'єктно-орієнтованого підходу до розробки системи з орієнтацією на доменну модель проблемної області.
     Перший шар, або рівень домену, є найближчим до проблемної області програмної системи. У цьому шарі розміщуються сутності, виключення, об'єкти значень та перелічення, які відображають ключові або основні аспекти риборозплідних ставів та їх управління.
     Другий рівень, або рівень застосунку, включає поведінкові класи, команди, запити та інтерфейси, які взаємодіють з сутностями з шару домену. У цьому рівні знаходяться класи, що реалізують бізнес-логіку програми та відповідають за обробку запитів користувача або системних подій. Поведінкові класи визначають способи взаємодії між об'єктами доменного рівня, а також виконують операції, необхідні для досягнення поставлених завдань. Команди та запити використовуються для передачі дій до доменного рівня, де вони інтерпретуються та виконуються. Інтерфейси забезпечують взаємодію користувача або зовнішніх систем з додатком, дозволяючи їм взаємодіяти з сутностями та функціями, що надаються програмною системою.
     Третій рівень, або рівень інфраструктури, включає в себе компоненти, необхідні для забезпечення функціональності програмної системи. Сюди входять база даних, міграції, конфігурації, класи, що відповідають за авторизацію та автентифікацію користувачів, а також реалізацію інтерфейсів попереднього рівня. База даних використовується для зберігання інформації про риборозплідні стави, їх стан та інші важливі дані. Міграції використовуються для керування структурою бази даних та забезпечення її сумісності з новими версіями програми. Конфігурації визначають параметри та налаштування системи. Класи авторизації та автентифікації відповідають за перевірку прав доступу користувачів до різних частин системи. Реалізація інтерфейсів забезпечує комунікацію між цим рівнем та рівнем застосунку.
     Четвертий рівень, рівень презентації, включає контролери для обробки HTTP запитів, налаштування програми, контейнер впровадження залежностей та проміжне програмне забезпечення. Контролери для обробки HTTP запитів відповідають за приймання вхідних запитів від клієнтів та виклик відповідних функцій або сервісів для їх обробки. Налаштування програми визначають параметри та конфігурації, необхідні для правильної роботи програми в різних середовищах. Контейнер впровадження залежностей використовується для управління залежностями та ін'єкції залежностей в об'єкти в рамках програми. Проміжне програмне забезпечення використовується для обробки запитів перед їх подальшою обробкою контролерами або після їх обробки для виконання додаткових дій таких як аутентифікація, авторизація тощо. 
     Додатковим шаром є шар ресурсів, який містить в собі інформацію для глобалізації. Цей шар включає тексти, переклади та інші ресурси, які використовуються для адаптації програмного забезпечення до різних мов та культурних контекстів. Тут зберігаються рядки для інтерфейсу користувача, повідомлення про помилки, формати дат та часу, валюти та інші локалізовані дані, що дозволяють програмі взаємодіяти з користувачами у різних країнах та регіонах.
     

2.2 Побудова діаграми розгортання
     
     
     Розроблювана система інтегрує в себе різноманітні компоненти, що охоплюють серверну частину, веб-додаток, мобільний додаток та розумний пристрій. Ця комплексна архітектура сприяє широкому охопленню користувачів і дозволяє забезпечити високий рівень доступності та зручності взаємодії. Відображення компонентів системи на діаграмі розгортання (див. рис. 2.2.1) надає зрозумілу візуальну репрезентацію їх взаємозв'язків та розміщення, що є важливим для ефективного управління та розгортання системи.
     

Рисунок 2.2.1 – Діаграма розгортання
     

     2.3 Побудова ER-діаграми 
     
     
     Після аналізу системи було створено ER-діаграму бази даних для наочного відображення структури та зв'язків між різними сутностями. База даних складається з трьох основних таблиць: «Користувачі» («Users»), «Стави» («Ponds») та «Графіки годування» («FeedingSchedules»). Кожна таблиця має свій власний унікальний ідентифікатор в якості первинного ключа, що дозволяє однозначно ідентифікувати кожен запис.
     Для створення ER-діаграми були визначені основні сутності та їх атрибути, а також зв'язки між ними. У процесі моделювання були враховані потреби системи та вимоги до зберігання та обробки даних. Результатом цього аналізу стала чітка структура бази даних, яка відображає основні об'єкти та взаємозв'язки між ними, що відображено на ER-діаграмі.
     

Рисунок 2.2.1 – ER-діаграма
     
     
     2.4 Опис архітектури серверної частини
     2.4.1 Створення бази даних та робота з даними
     
     
     Для реалізації бази даних системи був обраний підхід «Code First», що передбачає автоматичне створення структури бази даних на основі класів, описаних у програмному коді, за допомогою міграцій. У доменному шарі було спеціально створено каталог з назвою «Entities», де були описані сутності бази даних.
     Цей підхід дозволяє зосередитися на програмуванні логіки додатку, не втрачаючи часу на вручну створення та оновлення схеми бази даних. Замість цього, ми можемо просто створювати та змінювати класи, які відображають структуру даних, а система Entity Framework [3] відповідно створює або мігрує базу даних, використовуючи ці класи як вихідний шаблон.
     Було створено базовий клас дозволяє спадкувати загальні властивості для всіх сутностей у системі, що допомагає уникнути дублювання коду та спрощує управління часовими мітками та ідентифікацією записів:
1. /// <summary>
2. /// Represents a base entity with common properties.
3. /// </summary>
4. public class BaseEntity
5. {
6.     /// <summary>
7.     /// Gets or sets the unique identifier of the entity.
8.     /// </summary>
9.     public Guid Id { get; set; }
10.         
11.     /// <summary>
12.     /// Gets or sets the date and time when the entity was created, in UTC.
13.     /// </summary>
14.     public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
15. }
     Для роботи з базою даних у проекті було використано Entity Framework, а система управління базами даних PostgreSQL [8] обрана як оптимальне рішення для потреб проекту. Після успішного налаштування бази даних було впроваджено шаблон «Репозиторій», який використовується для ізоляції бізнес-логіки від деталей роботи з даними. Цей підхід дозволяє зберігати та отримувати дані без прямого залучення у рівні бізнес-логіки, забезпечуючи кращу модульність та масштабованість системи. Спочатку були створені інтерфейси, які визначають методи, що будуть реалізовані у відповідному класі репозиторію, зокрема, прикладами є інтерфейси IRepository<T> та IUnitOfWork. Цей підхід дозволяє забезпечити єдність і структурованість управління даними та робить код більш читабельним та легким для розуміння та підтримки. Код інтерфейсу IRepository<T> можна знайти в додатку А.
     
     2.4.2 Використання CQRS, MediatR та контролерів
     
     
     Для реалізації шаблону CQRS (Command Query Responsibility Segregation) та керування запитами та командами у системі використовувався NuGET [7] пакет MediatR. Цей пакет надає простий та ефективний механізм для обробки запитів та команд у додатку. Завдяки MediatR, реалізація шаблону CQRS стала більш зручною та прозорою, що сприяє полегшенню розробки та підтримки системи.
     У шарі додатку були створені класи запитів та команд, які відповідають за представлення оброблюваних запитів та команд системи. Ці класи відображають конкретні дії, які потрібно виконати в системі, і включають у себе необхідні дані для їх виконання. Крім того, вони забезпечують розділення логіки запитів та команд, що сприяє підтримці принципів чистої архітектури та розбиття системи на логічні компоненти.
     Використання класів запитів та команд у шарі додатку дозволяє забезпечити чітку структуру та розділення відповідальностей між частинами системи. Це дозволяє зробити код більш читабельним, модульним та легко зрозумілим для інших розробників. Такий підхід сприяє полегшенню розвитку та підтримки програмного забезпечення, а також підвищує його якість та надійність.
     Приклад команди для реєстрації в системі користувача:
1. public record RegisterWorkerCommand(string FullName, string Username, string Email, string Password) : IRequest<string>;
     Для кожної команди та запиту в системі було створено відповідний обробник та клас, який відповідає за перевірку та верифікацію даних, що надходять. Цей підхід дозволяє розділити логіку обробки запитів та команд від логіки перевірки даних, що забезпечує кращу читабельність та масштабованість системи. Деякі запити потребували спеціального обробника для виконання певних дій або операцій над даними, тому було створено відповідні обробники, які забезпечують цю функціональність.
1. public sealed class RegisterWorkerCommandHandler : IRequestHandler<RegisterWorkerCommand, string>
2. {
3.     private readonly IUnitOfWork _unitOfWork;
4.     private readonly IUserRepository _userRepository;
5.     private readonly IMapper _mapper;
6. 
7.     public RegisterWorkerCommandHandler(IUnitOfWork unitOfWork, IUserRepository userRepository, IMapper mapper)
8.     {
9.         _unitOfWork = unitOfWork;
10.         _userRepository = userRepository;
11.         _mapper = mapper;
12.     }
13. 
14.     public async Task<string> Handle(RegisterWorkerCommand request, CancellationToken cancellationToken)
15.     {
16.         var user = _mapper.Map<User>(request);
17.         var token = await _userRepository.RegisterUserAsync(user, request.Password, cancellationToken);
18.         await _unitOfWork.SaveChangesAsync(cancellationToken); 
19.         return token;
20.     }
21. }
     Додатково, для деяких запитів було створено відповідні профілі, які відповідають за перетворення команд до сутностей доменного шару. Ці профілі дозволяють узагальнити логіку перетворення даних та забезпечити їх правильність та цільову орієнтацію для використання у різних частинах системи. Такий підхід спрощує розробку та підтримку системи, оскільки дозволяє уникнути дублювання коду та забезпечити єдність логіки обробки даних.
1. public class RegisterWorkerCommandProfile : Profile
2. {
3.     public RegisterWorkerCommandProfile()
4.     {
5.         CreateMap<RegisterWorkerCommand, User>();
6.     }
7. }
     Кожен контролер у системі був ретельно розроблений для обробки HTTP-запитів, що стосуються конкретної сутності. Ці контролери функціонували як посередники між клієнтом та серверною частиною додатку, забезпечуючи взаємодію із системою через HTTP-протокол. Кожен контролер відповідав за виконання різних операцій, таких як отримання даних, створення нових записів, оновлення та видалення даних.
     Кожен запит або команда, що надходила до контролера, передавалася до відповідного обробника запитів або команд для подальшої обробки. Ці обробники відповідали за виконання конкретних дій відповідно до отриманих від контролера інструкцій. Після завершення обробки запиту або команди результат повертався назад до контролера, який забезпечував передачу відповіді клієнту.
     Приклад контролера, що відповідає за роботу з даними користувачів наведено в додатку Б.


     2.4.3 Обробка помилок
     
     
     Для ефективного управління винятками у системі було розроблено проміжне програмне забезпечення для обробки винятків, яке відповідає за перехоплення та обробку помилок під час виконання запитів. Це ExceptionHandlingMiddleware дозволяє системі гнучко реагувати на можливі виняткові ситуації та надавати можливість відновлення нормальної роботи додатку після виникнення помилок.
     ExceptionHandlingMiddleware було інтегровано у систему як частину загальної архітектури обробки запитів, що дозволяло йому працювати з іншими компонентами системи у взаємодії. Це забезпечувало однорідність у реагуванні на помилки та підтримувало стабільність та надійність системи в цілому. Програмний код цього класу наведено в додатку В.
     
     
     2.4.4 Бізнес логіка
     
     
     Бізнес-логіка системи зосереджена на керуванні та оптимізації роботи з риборозплідними ставами. Головною функціональністю є створення ставів та ефективне керування їхніми даними. Клас репозиторію, який відповідає за основні дії над даними системи можна знайти в додатку Г.
     Керування даними ставів включає в себе моніторинг та збір інформації про стан ставів, таку як температура води, рівень кисню, кількість та розподіл риби тощо. Ця інформація використовується для аналізу та прийняття рішень щодо оптимальних умов утримання риби, а також для планування майбутніх заходів щодо покращення управління ставами.
     Бізнес-логіка системи також передбачає автоматизацію деяких процесів, таких як годівля риби, контроль рівня води в ставах, виявлення та вирішення потенційних проблем, що можуть виникнути у процесі експлуатації ставів. Це допомагає забезпечити ефективне та стабільне управління риборозплідними ставами з мінімальними втратами та оптимізацією виробничих процесів.
     У системі застосовуються математичні методи для обробки різноманітних даних, спрямованих на оптимізацію умов утримання риби та підтримання їхнього здоров'я. Наприклад, для визначення оптимальної кількості їжі, необхідної для риб, і встановлення інтервалу годування застосовуються відповідні розрахунки, що базуються на параметрах, таких як вага риби, температура води та її хімічний склад.
     Додатково, в системі реалізовані функціональності для конвертації температурних даних, об'єму їжі та рівня розчиненого аміаку до різних одиниць виміру. Наприклад, конвертація температури з градусів Цельсія до Фаренгейта, або перетворення ваги з кілограмів до фунтів. Ці обчислення дозволяють користувачам працювати з даними у форматі, який є більш зрозумілим або зручним для них, сприяючи зручності та ефективності використання системи. Такий підхід допомагає забезпечити точність та зрозумілість обробки даних у системі, що є важливим фактором для успішної експлуатації риборозплідних ставів.
     
     
     2.4.5 Можливість адміністрування системи
     
     
     Адміністраторам системи доступний широкий спектр функцій для керування системою. Головні можливості включають управління користувачами, що охоплює їх створення, видалення, перегляд та зміну ролей. Крім того, доступні інструменти для імпорту та експорту даних користувачів, що спрощує процес управління та забезпечує зручність у роботі з інформацією. 
     Також адміністраторам надається можливість управління інформацією про стави та відповідні графіки годування. Це включає створення, редагування, видалення та імпорт/експорт даних, що дозволяє забезпечити точне та зручне управління риборозплідними ставами та пов'язаною з ними інформацією.
     
     
     2.4.6 Локалізація
     
     
     Для забезпечення багатомовності та локалізації програми систематично використовуються файли ресурсів. Цей підхід забезпечує зручність та доступність для користувачів з різних країн та мовних середовищ, оскільки дозволяє відображати текст та інші елементи у відповідності з обраною мовою.
     Кожен файл ресурсів створюється з урахуванням конкретної мови та містить переклади текстів програми на цю мову. Таким чином, наявність відповідних файлів ресурсів для англійської та української мов гарантує, що користувачі можуть сприймати інтерфейс додатку мовою, зрозумілою для них.
     Наприклад клас перевірки коректності даних команди реєстрації користувача, який виконує важливу роль у забезпеченні правильного та безперервного функціонування системи. Цей клас відповідає за перевірку введених користувачем даних на відповідність заданим критеріям, що є важливою складовою у забезпеченні цілісності та безпеки інформації.
     Одним із ключових аспектів роботи цього класу є локалізація повідомлень про некоректні дані. Це означає, що система може надати користувачеві інформативне повідомлення про помилку на його рідній мові, що покращує взаєморозуміння та забезпечує зручність у використанні програми.
     Наприклад, якщо користувач введе некоректний електронний адрес або пароль, клас перевірки команди реєстрації користувача може вивести відповідне повідомлення про помилку, яке буде відображено на мові, встановленій в налаштуваннях програми. Цей підхід допомагає покращити взаємодію користувачів з програмним забезпеченням та забезпечує більш якісне використання системи. Код цього класу наведено в додатку Д.
     


     2.4.7 Інтернаціоналізація
     
     
     Інтернаціоналізація в системі також презентацію даних у різних одиницях виміру, зокрема температури, кількості їжі та рівня аміаку. Це означає, що користувачі з різних країн можуть бачити ці дані у вимірах, зрозумілих для них, що забезпечує зручність та зрозумілість інформації.
     Наприклад, температура може відображатися в градусах Цельсія або Фаренгейта в залежності від вибору користувача. Крім того, кількість їжі може представлятися в кілограмах та фунтах, а рівень аміаку - у міліграмах на літр та фунтах на унцію. Приклад методу, який повертає відповідні дані наведено в додатку Е.
     
     
     2.4.8 Облік часу
     
     
     Облік часу у системі ведеться в форматі UTC (Coordinated Universal Time) з урахуванням часового поясу. Це стандартизований глобальний час, який не залежить від географічного положення. Використання UTC дозволяє забезпечити точність відображення часових даних у всіх частинах світу, незалежно від місцевого часу. Крім того, система може автоматично адаптуватися до змін часового поясу, забезпечуючи коректне відображення часу під час переміщень користувачів або змін у часових поясах. Такий підхід до обліку часу сприяє уникненню плутанини і забезпечує коректне відображення подій та даних у системі.
     
     
     
     
     2.4.9 Захист даних
     
     
     Захист даних у системі є пріоритетною задачею, і для цього використовуються різноманітні заходи безпеки. Один із основних методів - це використання JWT [5] (JSON Web Token) для аутентифікації та авторизації користувачів. JWT дозволяє надійно передавати дані про авторизованого користувача між клієнтом та сервером, забезпечуючи захист від підроблення даних і підміни ідентифікаторів.
     Крім того, для забезпечення безпеки під час передачі даних через мережу використовується протокол HTTPS (Hypertext Transfer Protocol Secure), який забезпечує шифрування та захист від перехоплення чутливої інформації, такої як паролі або особисті дані.
     У базі даних вразлива інформація, така як паролі або особисті дані користувачів, зберігається у закодованому вигляді. Кодування дозволяє перетворити чутливу інформацію в незрозумілу послідовність символів, яка важко піддається розшифруванню навіть у випадку незаконного доступу до бази даних.
     Всі ці заходи безпеки разом забезпечують надійний захист даних у системі, зменшуючи ризик несанкціонованого доступу або витоку конфіденційної інформації.
     
     
     2.5 Побудова діаграми прецедентів
     
     
     Функціональні можливості, які були визначені у документі Vision & Scope для розробки серверної частини системи, були агреговані та представлені у вигляді діаграми прецедентів (див. рис. 2.5.1). У цій системі існують три основних актори: незареєстрований користувач, працівник та адміністратор. Кожен з цих акторів виконує свої унікальні ролі та має доступ до визначених функціональних можливостей, що забезпечують широкий спектр можливостей та взаємодії з системою. Діаграма прецедентів надає зрозуміле візуальне представлення цих можливостей та взаємозв'язків між ними, що сприяє кращому розумінню та управлінню функціональними вимогами системи.
     

Рисунок 2.5.1 – Діаграма прецедентів

     2.6 Специфікація REST

     
     REST API системи для управління риборозплідними ставами містить 17 кінцевих точок, що дозволяють взаємодіяти з різними аспектами системи. Специфікація REST API та опис кожної кінцевої точки наведений у таблиці 2.6.1. Рівні доступу до цих кінцевих точок включають неавторизованих користувачів, працівників та адміністраторів, які мають доступ до системи.
     
      Таблиця 2.6.1 – Специфікація REST API
Рівень доступуПосилання на кінцеву точкуHTTP-методПризначенняВсі/api/Users/loginPOSTРеєстрація користувачаВсі/api/Users/login                    POST            Авторизація користувачаАдміністратор        /api/Users                         GET             Отримання списку користувачівАдміністратор        /api/Users              DELETE          Видалення користувачаПрацівник        /api/Users/UpdatePUT             Оновлення даних користувачаАдміністратор        /api/Users/make-admin                   POST            Надання статусу адміністратораАдміністратор/api/Users/exportGET             Експорт даних користувачівАдміністратор/api/Users/importPOST            Імпорт даних користувачів

      Продовження табл. 2.6.1
Рівень доступуПосилання на кінцеву точкуHTTP-методПризначенняПрацівник        /api/FeedingSchedules POST            Створення графіку годуванняПрацівник        /api/FeedingSchedules PUT             Оновлення графіку годуванняАдміністратор        /api/FeedingSchedules DELETE          Видалення графіку годуванняАдміністратор        /api/FeedingSchedules/exportGET             Експорт даних графіків годуванняАдміністратор        /api/FeedingSchedules/importPOST            Імпорт даних графіків годуванняАвторизований        /api/Ponds POST            Створення ставуАвторизований        /api/Ponds GET             Отримання даних про ставАдміністратор        /api/Ponds/exportGET             Експорт даних про ставАдміністратор        /api/Ponds/importPOST            Імпорт даних про став




     2.7 Побудова діаграми компонентів
     
     
     Для створення діаграми компонентів спочатку проведено детальний аналіз системи, під час якого були ідентифіковані основні компоненти та їх взаємозв'язки. На основі цього аналізу було розібрано систему на окремі логічні компоненти, які відповідають за різні частини функціональності.
     Після ідентифікації основних компонентів системи було вирішено розмістити їх у відповідних пакетах та шарах архітектури. Це дозволило логічно та структурно організувати компоненти системи та визначити їх взаємозв'язки.
     В процесі створення діаграми були враховані не лише функціональні аспекти системи, а й її архітектурні принципи та вимоги до розгортання. Це дозволило побудувати діаграму компонентів, яка відображає не лише логічну структуру системи, а й її фізичну організацію та взаємозв'язки між компонентами.
     
     

Рисунок 2.7.1 – Діаграма компонентів
     
     * 
3 РОЗРОБКА ВЕБ ЧАСТИНИ ПРОЕКТУ
3.1 Опис прийнятих інженерних рішень та веб-компонентів
     
     
     Для реалізації клієнтської частини проекту було прийнято рішення використати Angular [1], що забезпечує сучасний та ефективний підхід до розробки веб-додатків. Використання Angular дозволило організувати проект у вигляді модульної структури, що забезпечує легкість у розширенні та підтримці коду. Кожен модуль і компонент мають чітко визначену відповідальність, що сприяє зручному управлінню функціоналом та взаємодії між різними частинами системи. Компоненти системи відображені на діаграмі компонентів Angular (див. рис. 3.1.1).
     

Рисунок 3.1.1 – Діаграма компонентів
      Нижче наведено опис прийнятих інженерних рішень та використаних веб-компонентів, організованих за структурою проекту.
     Модуль auth відповідає за аутентифікацію користувачів у системі. Він містить компоненти для реєстрації, входу та виходу користувачів, а також для управління токенами аутентифікації. Це забезпечує безпечний доступ до функціоналу додатка відповідно до ролі користувача.
     У каталозі core знаходяться два ключових каталоги: models та services.
     У каталозі models зберігаються моделі даних, що використовуються в додатку. Вони визначають структуру об'єктів, які передаються між клієнтською та серверною частинами.
     Каталог services містить сервіси, що реалізують бізнес-логіку та забезпечують взаємодію з сервером.
     Модуль ponds призначений для управління даними, пов'язаними з бізнес логікою системи.
     Компонент navbar, що знаходиться у каталозі shared, є спільним для всього додатка і забезпечує навігацію між різними розділами системи. Він включає елементи меню, які дозволяють користувачам швидко переміщуватися між основними функціональними модулями додатка.
     Модуль users відповідає за управління інформацією про користувачів системи. 
     Система реалізує взаємодію з двома видами користувачів: неавторизований користувач та адміністратор. Повний функціонал, доступний для кожного з цих типів користувачів, детально описано на діаграмі прецедентів (див. рис. 3.1.2). 

Рисунок 3.1.2 – Діаграма прецедентів

     На рис. 3.1.3 зображено діаграму діяльності. У цій діаграмі зображені переходи всередині системи, дані, що вводять користувачі, а також результати їх дій.
     

Рисунок 3.1.3 – Діаграма прецедентів
     

3.2 Реалізація веб-частини системи
     3.2.1 Авторизація та управління доступом користувачів
     
     
     Неавторизований користувач потрапляє на сторінку авторизації, де має можливість зареєструватися або авторизуватися:
     

Рисунок 3.2.1.1 – Сторінка авторизації
     
     Цей компонент реалізує авторизацію за допомогою відповідного сервісу – auth.service.ts (див. додаток Ж). 
     	Сервіс HttpService є ключовим компонентом для здійснення HTTP-запитів у проекті. Його головна мета – забезпечити стандартизовані методи для взаємодії з сервером, включаючи відправлення GET, POST, PUT та DELETE запитів. Цей сервіс значно спрощує роботу з HTTP-запитами та обробкою відповідей, забезпечуючи централізовану обробку помилок і автоматичне додавання заголовків аутентифікації та використовується у всіх сервісах для взаємодії з сервером. Код HttpService наведено у додатку К.
     

Рисунок 3.2.1.2 – Початкова сторінка після авторизації
     3.2.2 Обробка помилок
     
     
     Обробка помилок є критичним аспектом для забезпечення надійності та стабільності роботи клієнтського додатку. У проекті використовується вищезазначений сервіс HttpService, який реалізує централізовану обробку помилок під час виконання HTTP-запитів. Це дозволяє забезпечити уніфіковану реакцію на помилки та їхнє коректне оброблення у всіх частинах додатку.
     Сервіс HttpService використовує метод handleError для обробки помилок, що можуть виникнути під час виконання HTTP-запитів. Цей метод обробляє помилки, які надходять від HttpClient, що дозволяє компонентам додатку коректно реагувати на збої.
     

Рисунок 3.2.2.1 – Помилка при введенні хибного паролю


     3.2.3 Можливість адміністрування системи
     
     
     Користувач має доступ до сторінок адміністрування ставів та користувачів. На цих сторінках адміністратор має доступ до таких функцій, як: видалення запису, імпорт та експорт даних, а також збереження даних у PDF формат. Для користувачів є можливість зміни їх ролі.
     

Рисунок 3.2.3.1 – Сторінка адміністрування ставів


Рисунок 3.2.3.2 – Сторінка адміністрування користувачів  

     Для створення резервної копії даних є можливість збереження користувачів у файл з розширенням .json та завантаження користувачів з такого файлу у базу даних. Для цього на сторінці адміністрування користувачів є відповідні функції.
     
     
     3.2.4 Локалізація
     
     
     Для забезпечення локалізації ресурсів у відповідній мові для користувача використовується модуль TranslateModule. Локалізація дозволяє додатку динамічно відображати текст та інші ресурси на різних мовах, залежно від уподобань користувача.
     Для локалізації текстових ресурсів у додатку використовуються JSON файли, які містять ключ-значення пар для перекладу. Кожен мовний файл відповідає певній мові і містить переклади для різних текстових елементів інтерфейсу. Нижче наведено приклад мовного файлу en.json, що містить переклади для розділу користувачів.
     Код файлу en.json:
 1. {
 2.   "USERS": {
 3.     "TITLE": "Users",
 4.     "ID": "ID",
 5.     "FULLNAME": "Fullname",
 6.     "EMAIL": "Email",
 7.     "USERNAME": "Username",
 8.     "ROLE": "Role",
 9.     "REGISTRATION_DATE": "Registration Date"
10.   }
11. }


Рисунок 3.2.4.1  – Англійська версія додатку



Рисунок 3.2.4.2 – Українська версія додатку


     3.2.5 Облік часу
     
     
     У додатку Angular для обробки та відображення часу використовується DatePipe. Це дозволяє відображати дати і час у форматі, який відповідає локальним налаштуванням користувача. Використання DatePipe забезпечує коректне представлення часових даних відповідно до часової зони та формату дати, обраного користувачем.
     
     
     3.2.6 Бізнес логіка
     
     
     Реалізація бізнес логіки додатка буде показана у мобільному додатку системи. На стороні клієнта, як будо визначено у документі Vision & Scope, відбувається лише частина адміністрування системи. 	
4 РОЗРОБКА МОБІЛЬНОЇ ЧАСТИНИ ПРОЕКТУ
4.1 Опис прийнятих інженерних рішень та компонентів
     
     
     Для мобільної частини проекту було використано технології: мову програмування C# та платформу NET Multi-Platform App UI (.NET MAUI [6]) для розробки мобільних додатків. 
     Проект побудовано з використанням принципів Domain-Driven Design (DDD), що допомогло чітко розділити відповідальність між різними частинами системи та забезпечити високу розширюваність коду. Структура проекту включає наступні папки:
     Application, що містить логіку додатків, такі як сервіси та обробка команд.
     Domain – визначає основні бізнес-об'єкти та їхні правила.
     Infrastructure – реалізує взаємодію з зовнішніми системами.
     Presentation – відповідає за відображення даних та взаємодію з користувачем через UI.
     Для організації HTTP-запитів у проекті використовується HttpClientFactory. У проекті визначено базовий клас сервісу для виконання HTTP-запитів. Цей клас надає методи для виконання HTTP-запитів різного типу, підтримуючи авторизацію за допомогою токенів доступу та обробку відповідей.
     Мобільний застосунок передбачає реалізацію бізнес логіки системи, що була описана у документі Vision&Scope, для неавторизованого користувача наявна можливість авторизуватися. Детально можливості користувача проілюстровані на діаграмі прецедентів (див. додаток Л).





     
4.2 Реалізація мобільної частини системи
     4.2.1 Авторизація та управління доступом користувачів
     
     

Рисунок 4.2.1.1 – Сторінка авторизації
     
     Після успішної авторизації, сторінка, на яку потрапляє користувач – реалізація бізнес логіки проекту.

Рисунок 4.2.1.2 – Початкова сторінка
     
     
     4.2.2 Можливість адміністрування системи
     
     
     Можливість адміністрування реалізована для користувача клієнтського застосунку.
     
     
     
     4.2.3 Бізнес логіка
     
     
     Методи бізнес логіки реалізовані у відповідному сервісі додатку – PondService. У користувачів мобільного застосунку є можливість змінювати графіки годування для ставів, в залежності від певних умов та показників.
     Код класу PondService:
 1. namespace Infrastructure.Services
 2. {
 3.     public class PondService : ServiceBase, IPondService
 4.     {
 5.         public PondService(IHttpClientFactory httpClientFactory, AuthConfiguration authConfiguration)
 6.             : base(httpClientFactory, authConfiguration)
 7.         {
 8.         }
 9.
10.         public async Task<List<Pond>> GetPondsAsync(CancellationToken cancellationToken)
11.         {
12.             return await SendRequestAsync<List<Pond>>(HttpMethod.Get, "ponds/email", cancellationToken);
13.         }
14.
15.         public async Task UpdateScheduleAsync(Pond? currentEntity)
16.         {
17.             var request = new UpdateFeedingScheduleCommand(
18.                 currentEntity!.FeedingSchedule.Id, 
19.                 currentEntity!.Id, 
20.                 currentEntity!.FeedingSchedule.FeedingFrequencyInHours, 
21.                 currentEntity!.FeedingSchedule.FoodAmount);
22.             await SendRequestAsync(HttpMethod.Put, "feedingSchedules", request, CancellationToken.None);
23.         }
24.     }
25. }


Рисунок 4.2.3.1 – Сторінка налаштування ставу (бізнес-логіка)


     4.2.4 Локалізація
     
     
     Для локалізації мобільного застосунку використовуються файли ресурсів та в залежності від конфігурації Android пристрою користувач бачить англійську чи українську версію додатку.
     

Рисунок 4.2.4.1 – Інтерфейс англійською

Рисунок 4.2.4.2 – Інтерфейс українською

     Таким чином користувач може побачити інтерфейс тією мовою, яка буде зручніша та зрозуміліша для них. Обрана мова автоматично підлаштовується під системну. 
     
ВИСНОВКИ
     
     
     Було розроблено програмну систему для спостереження за станом ставів для розведення риби з використанням низки технологій таких як .NET, Postgres, Angular, Typescript, SASS,  та MAUI. Додатково було використано бібліотеки що надає платформа NuGET та NPM. Вони забезпечують надійність, швидкість та зручність у роботі з системою. .NET та Postgres забезпечують потужну серверну базу, здатну обробляти великі обсяги даних, тоді як Angular та Typescript дозволяють побудувати дружній інтерфейс користувача, який працює однаково як на веб-платформі, так і на мобільних пристроях. Використання SASS дозволяє забезпечити стиль і зручність веб-інтерфейсу, забезпечуючи привабливий вигляд і легкість в управлінні. MAUI додає можливість розширення цієї системи на мобільні платформи, роблячи її ще більш доступною та зручною для користувачів.
     Для отримання повноцінної злагодженої системи було створено серверну та клієнтську (веб та мобільний додатки) частини. Розроблена система надає низку функціональностей, які необхідні власниками риборозплідних ставів, таких як створення необхідних акаунтів та керування доступом, створення та ведення даних про стави, створення графіків годівлі та догляд за різними видами риб. За допомогою розробленої програмної системи, власники риборозплідних ставів можуть ефективно керувати всіма аспектами їхнього бізнесу. Вони отримують можливість не лише зберігати та відстежувати дані про стави, а й використовувати аналітичні інструменти для оптимізації процесів годівлі та догляду за рибою.
     

     
     
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


     1. Angular. Home • Angular. URL: https://angular.dev/ (дата звернення: 14.06.2024).
     2. Aquabyte - Maskinlæring, datateknologi og bærekraft. Aquabyte. URL: https://www.aquabyte.no/?gad_source=1&amp;gclid=CjwKCAjw1K-zBhBIEiwAWeCOF9xp3n3UF856B7uCjTfZwPaC2mzqO0A0b_QlwjQpxpDvoMvZMffSvhoCC60QAvD_BwE (дата звернення: 14.06.2024).
     3. Entity Framework documentation hub. Microsoft Learn: Build skills that open doors in your career. URL: https://learn.microsoft.com/en-us/ef/ (дата звернення: 14.06.2024).
     4. Home. CageEye. URL: https://cageeye.com/ (дата звернення: 14.06.2024).
     5. Jwt.io. JSON Web Tokens - jwt.io. URL: https://jwt.io/ (дата звернення: 14.06.2024).
     6. .NET multi-platform app UI (.NET MAUI) | .NET. Microsoft. URL: https://dotnet.microsoft.com/en-us/apps/maui (дата звернення: 14.06.2024).
     7. NuGet gallery | home. NuGet Gallery | Home. URL: https://www.nuget.org/ (дата звернення: 14.06.2024).
     8. PostgreSQL. PostgreSQL. URL: https://www.postgresql.org/ (дата звернення: 14.06.2024).





      ДОДАТОК А
      Код інтерфейсу IRepository<T>
      

1. /// <summary>
2. /// Represents a generic repository interface for CRUD operations on entities.
3. /// </summary>
4. /// <typeparam name="T">The type of entity.</typeparam>
5. public interface IRepository<T> where T : BaseEntity
6. {
7.     /// <summary>
8.     /// Asynchronously creates a new entity.
9.     /// </summary>
10.     /// <param name="entity">The entity to create.</param>
11.     /// <param name="cancellationToken">The cancellation token.</param>
12.     Task CreateAsync(T entity, CancellationToken cancellationToken);
13. 
14.     /// <summary>
15.     /// Updates an existing entity.
16.     /// </summary>
17.     /// <param name="entity">The entity to update.</param>
18.     void Update(T entity);
19. 
20.     /// <summary>
21.     /// Deletes an entity.
22.     /// </summary>
23.     /// <param name="entity">The entity to delete.</param>
24.     void Delete(T entity);
25. 
26.     /// <summary>
27.     /// Asynchronously retrieves an entity by its unique identifier.
28.     /// </summary>
29.     /// <param name="id">The unique identifier of the entity.</param>
30.     /// <param name="cancellationToken">The cancellation token.</param>
31.     /// <returns>The retrieved entity, or null if not found.</returns>
32.     Task<T?> GetAsync(Guid id, CancellationToken cancellationToken);
33. 
34.     /// <summary>
35.     /// Asynchronously retrieves all entities.
36.     /// </summary>
37.     /// <param name="cancellationToken">The cancellation token.</param>
38.     /// <returns>A list of entities.</returns>
39.     Task<List<T>> GetAsync(CancellationToken cancellationToken);
40. 
41.     /// <summary>
42.     /// Gets a queryable representation of entities for advanced querying.
43.     /// </summary>
44.     /// <returns>An IQueryable representing the entities.</returns>
45.     IQueryable<T> GetQueryable();
46. 
47.     /// <summary>
48.     /// Exports entities to JSON asynchronously.
49.     /// </summary>
50.     /// <param name="cancellationToken">Cancellation token.</param>
51.     /// <returns>A task representing the asynchronous operation. The task result contains the JSON data.</returns>
52.     Task<string> ExportToJsonAsync(CancellationToken cancellationToken);
53. 
54.     /// <summary>
55.     /// Imports entities from JSON asynchronously.
56.     /// </summary>
57.     /// <param name="json">JSON string containing the entities.</param>
58.     /// <param name="cancellationToken">Cancellation token.</param>
59.     /// <returns>A task representing the asynchronous operation. The task result contains a collection of imported entities.</returns>
60.     Task<ICollection<T>> ImportFromJsonAsync(string json, CancellationToken cancellationToken);
61. }

















      ДОДАТОК Б
      Код класу контролеру користувачів UsersController


1. [Route("api/[controller]")]
2. [ApiController]
3. public class UsersController : ControllerBase
4. {
5.     private readonly IMediator _mediator;
6.
7.     public UsersController(IMediator mediator)
8.     {
9.         _mediator = mediator;
10.     }
11. 
12.     [HttpPost("login")]
13.     public async Task<ActionResult> Login(LoginQuery request, CancellationToken cancellationToken)
14.     {
15.         var response = await _mediator.Send(request, cancellationToken);
16.         return Ok(response);
17.     }
18.     
19.     [HttpPost("register")]
20.     public async Task<ActionResult> Create(RegisterWorkerCommand request, CancellationToken cancellationToken)
21.     {
22.         var response = await _mediator.Send(request, cancellationToken);
23.         return Ok(response);
24.     }
25. 
26.     [Authorize(Roles = nameof(Role.Admin))]
27.     [HttpGet]
28.     public async Task<ActionResult> Get(CancellationToken cancellationToken)
29.     {
30.         var response = await _mediator.Send(new GetAllUsersQuery(), cancellationToken);
31.         return Ok(response);
32.     }
33.     
34.     [Authorize(Roles = nameof(Role.Admin))]
35.     [HttpDelete]
36.     public async Task<ActionResult> Delete([FromQuery] Guid userId, CancellationToken cancellationToken)
37.     {
38.         var response = await _mediator.Send(new DeleteUserCommand(userId), cancellationToken);
39.         return Ok(response);
40.     }
41. 
42.     [Authorize(Roles = nameof(Role.Admin))]
43.     [HttpPost("make-admin")]
44.     public async Task<ActionResult> MakeAdmin([FromQuery] Guid userId, CancellationToken cancellationToken)
45.     {
46.         var response = await _mediator.Send(new MakeAdminCommand(userId), cancellationToken);
47.         return Ok(response);
48.     }
49. 
50.     [Authorize]
51.     [HttpPut]
52.     public async Task<ActionResult> Update(UpdateUserCommand request, CancellationToken cancellationToken)
53.     {
54.         var response = await _mediator.Send(request, cancellationToken);
55.         return Ok(response);
56.     }
57. }






























      ДОДАТОК В
      Код класу ExceptionHandlingMiddleware


1. public class ExceptionHandlingMiddleware
2. {
3.     private readonly RequestDelegate _next;
4.     private readonly ILogger<ExceptionHandlingMiddleware> _logger;
5. 
6.     public ExceptionHandlingMiddleware(RequestDelegate next, ILogger<ExceptionHandlingMiddleware> logger)
7.     {
8.         _next = next;
9.         _logger = logger;
10.     }
11. 
12.     public async Task InvokeAsync(HttpContext context)
13.     {
14.         try
15.         {
16.             await _next(context);
17.         }
18.         catch (ExceptionBase ex)
19.         {
20.             _logger.LogError(ex, ex.Message);
21. 
22.             context.Response.StatusCode = (int)ex.HttpStatusCode;
23. 
24.             var problem = new ProblemDetails()
25.             {
26.                 Status = (int)ex.HttpStatusCode,
27.                 Type = ex.HttpStatusCode.ToString(),
28.                 Detail = ex.Message
29.             };
30. 
31.             string problemJson = JsonSerializer.Serialize(problem);
32.             context.Response.ContentType = "application/json";
33.             await context.Response.WriteAsync(problemJson);
34.         }
35.     }
36. }


























      ДОДАТОК Г
      Код класу Repository<T>


1. public class Repository<T> : IRepository<T> where T : BaseEntity
2. {
3.     protected readonly ApplicationDbContext Context;
4. 
5.     public Repository(ApplicationDbContext context)
6.     {
7.         Context = context;
8.     }
9. 
10.     public virtual async Task CreateAsync(T entity, CancellationToken cancellationToken)
11.     {
12.         await Context.AddAsync(entity, cancellationToken);
13.     }
14. 
15.     public void Update(T entity)
16.     {
17.         Context.Update(entity);
18.     }
19. 
20.     public void Delete(T entity)
21.     {
22.         Context.Remove(entity);
23.     }
24. 
25.     public virtual Task<T?> GetAsync(Guid id, CancellationToken cancellationToken)
26.     {
27.         return Context.Set<T>().FirstOrDefaultAsync(x => x.Id == id, cancellationToken: cancellationToken);
28.     }
29. 
30.     public Task<List<T>> GetAsync(CancellationToken cancellationToken)
31.     {
32.         return Context.Set<T>().ToListAsync();
33.     }
34. 
35.     public IQueryable<T> GetQueryable()
36.     {
37.         return Context.Set<T>();
38.     }
39. 
40.     public async Task<string> ExportToJsonAsync(CancellationToken cancellationToken)
41.     {
42.         var entities = await Context.Set<T>().ToListAsync(cancellationToken);
43.         return JsonConvert.SerializeObject(entities);
44.     } 
45.     public async Task<ICollection<T>> ImportFromJsonAsync(string json, CancellationToken cancellationToken)
46.     {
47.         var importedEntities = JsonConvert.DeserializeObject<ICollection<T>>(json)!;
48.         await Context.Set<T>().AddRangeAsync(importedEntities, cancellationToken);
49.         return importedEntities;
50.     }
51. }




      ДОДАТОК Д
      Код класу RegisterWorkerCommandValidator
	

1. public class RegisterWorkerCommandValidator : AbstractValidator<RegisterWorkerCommand>
2. {
3.     public RegisterWorkerCommandValidator()
4.     {
5.         RuleFor(x => x.FullName)
6.             .NotEmpty().WithMessage(Resource.RequiredField)
7.             .MinimumLength(8).WithMessage(Resource.FullNameMustBeEightCharacters);
8. 
9.         RuleFor(x => x.Email)
10.             .NotEmpty().WithMessage(Resource.RequiredField)
11.             .EmailAddress().WithMessage(Resource.EmailNotValid);
12.         
13.         RuleFor(x => x.Username)
14.             .NotEmpty().WithMessage(Resource.RequiredField)
15.             .MinimumLength(5).WithMessage(Resource.UsernameMustBeFiveCharacters)
16.             .Matches("[a-z]+$").WithMessage(Resource.UsernameMustContainOnlyLowercase);
17. 
18.         RuleFor(x => x.Password)
19.             .NotEmpty().WithMessage(Resource.RequiredField)
20.             .MinimumLength(8).WithMessage(Resource.PasswordBoundaries)
21.             .MaximumLength(32).WithMessage(Resource.PasswordBoundaries)
22.             .Matches(@"[A-Z]+").WithMessage(Resource.PasswordCharacters)
23.             .Matches(@"[a-z]+").WithMessage(Resource.PasswordCharacters)
24.             .Matches(@"[0-9]+").WithMessage(Resource.PasswordCharacters)
25.             .Matches(@"[\!\?\*\.]+").WithMessage(Resource.PasswordCharacters);
26.     }
27. }

























      ДОДАТОК Е
      Код методу GetDataAsync


1. public async Task<object> GetDataAsync(Guid pondId, CancellationToken cancellationToken)
2.     {
3.         var dataFromSmartDevice = await _smartDeviceService.GetDataFromPond(pondId);
4.         
5.         var temperatureInCelsius = 
6.             (double)dataFromSmartDevice.GetType().GetProperty("TemperatureInCelcius")!.GetValue(dataFromSmartDevice)!;
7.         var temperatureInFahrenheit = ConvertCelsiusToFahrenheit(temperatureInCelsius);
8. 
9.         var foodAmountInKilos =
10.             (double)dataFromSmartDevice.GetType().GetProperty("FoodAmountInKilos")!.GetValue(dataFromSmartDevice)!;
11.         var foodAmountInPounds = ConvertKilosToPounds(foodAmountInKilos);
12.         
13.         double dissolvedAmmoniaMgL = 
14.             (double)dataFromSmartDevice.GetType().GetProperty("DissolvedAmmoniaMgL")!.GetValue(dataFromSmartDevice)!;
15.         double dissolvedAmmoniaLbsOz = ConvertMgLtoLbsOz(dissolvedAmmoniaMgL);
16.         
17.         dataFromSmartDevice.GetType().GetProperty("TemperatureInFahrenheit")!.SetValue(dataFromSmartDevice, temperatureInFahrenheit);
18.         dataFromSmartDevice.GetType().GetProperty("FoodAmountInPounds")!.SetValue(dataFromSmartDevice, foodAmountInPounds);
19.         dataFromSmartDevice.GetType().GetProperty("DissolvedAmmoniaLbsOz")!.SetValue(dataFromSmartDevice, dissolvedAmmoniaLbsOz);
20. 
21.         return dataFromSmartDevice;
22.     }






















ДОДАТОК Ж
Код файлу AuthService


 1. import { Injectable } from '@angular/core';
 2. import { HttpService } from './http.service';
 3. import { Router } from '@angular/router';
 4. import { jwtDecode } from 'jwt-decode';
 5. import { UserToken } from '../models/userToken';
 6.
 7. @Injectable({
 8.   providedIn: 'root'
 9. })
10. export class AuthService {
11.
12.   private isAuthenticatedInterval: any;
13.
14.   constructor(
15.       private http: HttpService,
16.       private router: Router) { }
17.
18.   login(email: string, password: string) {
19.     this.http.post<string>('users/login', { login: email, password: password })
20.         .subscribe(
21.             (token: string) => {
22.               this.handleAuthentication(token);
23.             },
24.             (err) => {
25.               alert('Invalid email or password.');
26.             }
27.         );
28.   }
29.
30.   handleAuthentication(token: string) {
31.     const decodedToken: UserToken = jwtDecode(token);
32.     console.log(jwtDecode(token));
33.     if (decodedToken['http://schemas.microsoft.com/ws/2008/06/identity/claims/role'] !== 'Admin') {
34.         alert('You do not have permission to access this application.');
35.         return;
36.     }
37.
38.     localStorage.setItem('token', token);
39.     localStorage.setItem('userName', decodedToken.name);
40.     localStorage.setItem('userEmail', decodedToken.email);
41.
42.     this.router.navigate(['/users']).then(() => window.location.reload());
43.   }
44.
45.   isAuthenticated() {
46.     const token = localStorage.getItem('token');
47.
48.     if (token) {
49.       const decodedToken: UserToken = jwtDecode(token);
50.       return decodedToken.exp > Date.now() / 1000;
51.     }
52.
53.     return false;
54.   }
55.
56.   startAuthenticatedCheck() {
57.     if (this.isAuthenticatedInterval) {
58.       clearInterval(this.isAuthenticatedInterval);
59.     }
60.
61.     this.isAuthenticatedInterval = setInterval(() => {
62.       if (!this.isAuthenticated()) {
63.         alert('Your session has expired. Please login again.');
64.         this.router.navigate(['/login']);
65.       }
66.     }, 60000);
67.   }
68.
69.   logout() {
70.     localStorage.removeItem('token');
71.     localStorage.removeItem('userName');
72.     localStorage.removeItem('userEmail');
73.
74.     this.router.navigate(['/login']).then(() => window.location.reload());
75.   }
76. } 

















ДОДАТОК К
Код файлу HttpService


 1. import { Injectable } from '@angular/core';
 2. import { HttpClient, HttpErrorResponse, HttpHeaders } from '@angular/common/http';
 3. import { Observable, catchError, throwError } from 'rxjs';
 4. import { environment } from '../../../environments/environment.development';
 5.
 6. @Injectable({
 7.   providedIn: 'root'
 8. })
 9. export class HttpService {
10.
11.   private baseUrl = environment.apiUrl;
12.
13.   constructor(private httpClient: HttpClient) { }
14.
15.   get<T>(url: string): Observable<T> {
16.     return this.httpClient.get<T>(this.buildUrl(url), this.getHeaders()).pipe(catchError(this.handleError));
17.   }
18.
19.   post<T>(url: string, resource: unknown) {
20.     return this.httpClient.post<T>(this.buildUrl(url), resource, this.getHeaders()).pipe(catchError(this.handleError));
21.   }
22.
23.   delete(url: string) {
24.     return this.httpClient.delete(`${this.buildUrl(url)}`, this.getHeaders()).pipe(catchError(this.handleError));
25.   }
26.
27.   put<T>(url: string, resource: T) {
28.     return this.httpClient.put<T>(this.buildUrl(url), resource, this.getHeaders()).pipe(catchError(this.handleError));
29.   }
30.
31.   private handleError(err: HttpErrorResponse) {
32.     return throwError(() => err);
33.   }
34.
35.   private buildUrl(url: string): string {
36.     return this.baseUrl + url;
37.   }
38.
39.   private getHeaders(): { headers?: HttpHeaders } {
40.     const token = localStorage.getItem('token');
41.     if (token) {
42.       const headers = new HttpHeaders({
43.         'Authorization': `Bearer ${token}`
44.       });
45.       return { headers };
46.     }
47.     return {};
48.   }
49. }









ДОДАТОК Л
Діаграма прецедентів




Рисунок Л.1 – Діаграма прецедентів











ДОДАТОК М
Перевірка на плагіат


 Рисунок М.1 – Результат перевірки на плагіат
                0     
     
